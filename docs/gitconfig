  git config --global user.email "karthikgood@gmail.com"
  git config --global user.name "karthikgood"
  git remote set-url origin https://{MYPERSONAL_GITHUB_TOKEN}@github.com/karthikgood/myscripts
  stage and commit
  git push origin main
  git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim

Setting up a Git repository on Linux is a straightforward process. Since you have already been working with Ansible and Terraform, initializing a Git repository is the best way to track your configuration changes and prepare your code for the GitHub Actions workflow we discussed.1. Install GitFirst, ensure Git is installed on your Linux machine.Bashsudo apt update
sudo apt install git -y
2. Configure Your IdentityBefore you start committing, you need to tell Git who you are. This information is attached to your commits.Bashgit config --global user.name "Your Name"
git config --global user.email "youremail@example.com"
3. Initialize and Connect a RepositoryThere are two ways to do this: starting fresh locally or cloning an existing repo.Option A: Create a New Local RepoRun this inside your project folder (my-automation):Bashgit init
Option B: Connect to GitHubOnce youâ€™ve created a repository on GitHub, link your local folder to it:Bashgit remote add origin https://github.com/username/repository-name.git
4. The "Stage, Commit, Push" WorkflowGit uses a three-tier system: the Working Directory (files you're editing), the Staging Area (files ready to be saved), and the Repository (saved history).Step 1: Stage your changesThis "adds" files to the staging area, telling Git you want to include them in the next snapshot.Stage specific file: git add setup.ymlStage everything: git add .Step 2: Commit your changesThis saves the staged snapshot to your local history. Always include a meaningful message.Bashgit commit -m "Add Rancher Desktop and Helm roles"
Step 3: Push to GitHubThis sends your local commits to the remote server (GitHub), which will trigger the GitHub Action we set up.Bashgit push origin main
5. Essential Git Commands Cheat SheetActionCommandDescriptionCheck Statusgit statusSee which files are modified or staged.View Historygit log --onelineSee a condensed list of previous commits.Pull Changesgit pull origin mainDownload latest changes from GitHub to your machine.Discard Changesgit checkout -- <file>Revert a file back to the last committed state.Create Branchgit checkout -b feature-nameCreate a new "path" to test changes safely.Pro-Tip: The .gitignoreSince you are working with Ansible and Terraform, you must create a .gitignore file to prevent sensitive or junk files from being uploaded.File: .gitignorePlaintext.vault_pass
terraform/.terraform/
terraform/*.tfstate*
*.retry
.env
Using Branches is the industry standard for safe development. Instead of making changes directly to the "production-ready" code (your main branch), you create a sandbox (a branch) where you can experiment. If the experiment fails, you delete it. If it works, you merge it.

1. The Branching Workflow
The most common strategy is called Feature Branching. You keep main clean and only push tested, working code to it.

2. Practical Commands for Branching
Step A: Create and Switch to a New Branch
When you want to add a new Ansible role (e.g., monitoring), start by creating a branch:

Bash

git checkout -b feature-monitoring
The -b flag tells Git to create the branch if it doesn't exist.

Step B: Work and Commit
Make your changes to your Ansible roles. As you work, commit your progress locally:

Bash

git add roles/monitoring/
git commit -m "Add Prometheus installation tasks"
Step C: Compare with Main
Before merging, it's helpful to see exactly what you changed:

Bash

git diff main
3. Merging: Bringing Changes Home
Once you are confident the new role works (perhaps after running it locally), you move the changes back to your main branch.

Switch back to main:

Bash

git checkout main
Pull latest changes (if working in a team):

Bash

git pull origin main
Merge your feature:

Bash

git merge feature-monitoring
Delete the branch (to keep things clean):

Bash

git branch -d feature-monitoring
4. Handling Conflicts
Sometimes you might change the same line in two different branches. This causes a Merge Conflict.

If this happens:

Git will pause the merge and mark the conflict in the file.

Open the file, look for <<<<<<< HEAD, and choose which version to keep.

Save the file, git add it, and run git commit.

How this ties into your GitHub Actions
Since we set up your GitHub Action to trigger on: push: branches: [ main ], your automation will not run while you are working on your feature branch. It will only trigger once you merge those changes into main and push. This prevents "broken" code from ever touching your real cluster.

Branch	Purpose	Triggers Automation?
main	Production-ready, stable code.	Yes
feature-x	Testing new roles or configs.	No

Export to Sheets

Would you like me to show you how to set up a "Pull Request" on GitHub, so that your code is automatically tested in a temporary environment before you're allowed to merge it into main?

A Pull Request (PR) is the "quality gate" of the DevOps world. Instead of just merging code yourself, a PR allows GitHub to act as a middlemanâ€”running tests and checks to prove the code is safe before it ever touches your main branch.

1. The Pull Request Workflow
This is how professional teams manage infrastructure. You "request" that your branch be "pulled" into the main project.

2. Step-by-Step: Setting up a PR
Step A: Push your feature branch
First, get your feature branch onto GitHub:

Bash

git checkout -b feature-monitoring
# ... make changes ...
git add .
git commit -m "Add monitoring role"
git push origin feature-monitoring
Step B: Open the PR on GitHub
Navigate to your repository on GitHub.

Youâ€™ll see a yellow bar saying "Compare & pull request." Click it.

Write a description of what this change does (e.g., "This PR adds Prometheus via Helm").

Click Create Pull Request.

3. Automating Tests with "PR Checks"
You can update your GitHub Actions so that every time a PR is opened, it runs a "Dry Run" (Check Mode) of your Ansible playbook. This verifies the syntax and logic without actually changing the server.

Update your .github/workflows/deploy.yml:

YAML

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ] # This triggers the workflow on PRs too!

jobs:
  test-and-deploy:
    runs-on: ubuntu-latest
    steps:
      # ... checkout and setup steps ...

      - name: Ansible Lint & Check Mode
        if: github.event_name == 'pull_request'
        run: |
          ansible-playbook -i inventory/hosts.ini setup.yml --check
          # The --check flag runs Ansible without making actual changes.
4. The "Checkmark" of Confidence
Once you save this, GitHub will show a status at the bottom of your PR.

ðŸŸ¢ Green Check: The Ansible syntax is correct and the dry run passed.

ðŸ”´ Red X: Something is wrong (e.g., a typo in your YAML). You must fix it and push again before you can merge.

5. Merging the PR
Once the checks are green, you (or a teammate) can click "Squash and merge." 1. The code moves into main. 2. The real deployment workflow triggers. 3. Your K3s cluster is updated.

Summary of your "Pro" Git Strategy
Branch: Create a branch for every new task.

PR: Open a Pull Request to trigger automated tests.

Review: Look at the green checkmarks to ensure your logic is sound.

Merge: Deploy to production with 100% confidence.

Would you like me to help you set up "Ansible Lint," which is a specialized tool that checks your playbooks for common mistakes and "bad smells" automatically during your PR?
Adding Ansible Lint to your workflow is like having a senior developer look over your shoulder 24/7. It catches common mistakes that might not cause a crash but are considered "bad practice"â€”like using the shell module when a specialized module exists, or forgetting to set file permissions.1. Update your GitHub ActionWe will add a step to your PR workflow that specifically runs ansible-lint. This will prevent "messy" code from ever being merged into your main branch.Update .github/workflows/deploy.yml:YAML      - name: Install Ansible Lint
        run: pip install ansible-lint

      - name: Run Ansible Lint
        run: ansible-lint ansible/setup.yml
2. Common "Rules" Ansible Lint EnforcesIf your code doesn't follow these rules, the GitHub Action will fail (turn Red), and you'll be forced to fix it.Rule IDNameWhat it catchesno-changed-whencommand-instead-of-moduleUsing shell: apt install instead of the apt module.risky-file-permissionsrisky-file-permissionsCreating a file without explicitly setting mode: '0644'.no-handlerno-handlerRestarting a service in a task instead of using a Handler.trailing-spacestrailing-spacesMessy whitespace at the end of lines.3. Local Linting (The Quick Way)You don't have to wait for GitHub to tell you there's a mistake. You can run the linting tool locally on your Linux machine before you even git push.Install and run locally:Bashpip install ansible-lint
ansible-lint setup.yml
4. Ignoring Rules (The "Escape Hatch")Sometimes you have a valid reason to break a rule. You can tell the linter to skip a specific line by adding a comment:YAML- name: Run a very specific script
  shell: ./my_weird_script.sh
  args:
    executable: /bin/bash
  tags:
    - skip_ansible_lint  # This tells the linter to ignore this task
Your Final DevOps Pipeline OverviewDevelop: Write code on a feature-branch.Lint: ansible-lint checks for best practices.Test: ansible --check performs a dry run.Review: You open a Pull Request and see the Green checks.Merge: Code goes to main.Deploy: Terraform and Ansible build your production K3s cluster.Would you like me to show you how to set up an "Ansible Galaxy" requirements file, so that your GitHub Action automatically installs any community-made roles or collections your project needs?

Pushing to a private repository from a Linux terminal or a CI/CD environment (like GitHub Actions) requires authentication. Since GitHub no longer accepts account passwords for command-line operations, you must use a Personal Access Token (PAT) or an SSH Key.1. Pushing via SSH (Recommended for Linux Terminals)SSH is the most secure and convenient way to interact with private repos from your local machine.The Workflow:Generate a key: ssh-keygen -t ed25519 -C "your_email@example.com"Add it to GitHub: Copy the output of cat ~/.ssh/id_rsa.pub and paste it into GitHub Settings > SSH and GPG keys.Set Remote URL: Ensure your remote is using the SSH format:Bashgit remote set-url origin git@github.com:username/repo-name.git
git push origin main
2. Pushing via HTTPS (Recommended for Automation)If you prefer HTTPS, you must use a Personal Access Token (PAT) as your password.The Workflow:Generate a PAT in GitHub Settings > Developer Settings > Personal Access Tokens.Store it in an Environment Variable:To avoid typing it every time, set it in your shell:Bashexport GITHUB_TOKEN="your_token_here"
Use it in the URL:Bashgit push https://$GITHUB_TOKEN@github.com/username/repo-name.git
3. Essential Environment Variables for CI/CDWhen using GitHub Actions, the runner is a fresh machine that knows nothing about you. You must set these variables in your YAML file to allow it to commit or push.Variable NamePurposeRecommended Value/SecretGITHUB_TOKENAutomatic token provided by GitHub to authenticate the runner.${{ secrets.GITHUB_TOKEN }}GIT_AUTHOR_NAMEThe name that appears on the commit history.github-actions[bot]GIT_AUTHOR_EMAILThe email associated with the bot.github-actions[bot]@users.noreply.github.comANSIBLE_VAULT_PASSWORDUsed by your playbook to decrypt secrets.${{ secrets.VAULT_PASSWORD }}4. Updating your GitHub Actions WorkflowHere is how you apply these variables so your GitHub Action can actually write back to your private repository (e.g., to update a version file or log).File: .github/workflows/deploy.ymlYAML      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Push Changes
        env:
          # Use the built-in token for authentication
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git add .
          git commit -m "Automated update from CI"
          git push origin main
Pro-Tip: Token PermissionsBy default, the ${{ secrets.GITHUB_TOKEN }} in Actions is often "Read Only." To allow it to push code to a private repo, you must grant it permissions at the top of your workflow file:YAMLpermissions:
  contents: write
Would you like me to show you how to use a "Deployment Key" instead? This is a special type of SSH key that only grants access to one specific private repository, making it even more secure for automation.
A Deploy Key is a specialized SSH key that lives inside a single GitHub repository rather than being tied to a personal user account. This is the "Gold Standard" for security because if the key is ever leaked, it only compromises that one specific project, not your entire GitHub account.1. Generate the Deployment KeyOn your local Linux machine, generate a dedicated key pair for this repo. Do not use a passphrase for keys intended for automation.Bashssh-keygen -t ed25519 -f ./id_deploy_key -N ""
This creates two files:id_deploy_key (The Private Key â€” Keep this secret)id_deploy_key.pub (The Public Key â€” Upload this to GitHub)2. Add the Public Key to GitHubGo to your Private Repository on GitHub.Navigate to Settings > Deploy keys.Click Add deploy key.Paste the contents of id_deploy_key.pub.Crucial: Check the box "Allow write access" so your automation can push changes back.3. Add the Private Key to GitHub SecretsIn the same repository, go to Settings > Secrets and Variables > Actions.Click New repository secret.Name it SSH_DEPLOY_KEY.Paste the entire contents of the private file (id_deploy_key).4. Configure the GitHub Actions WorkflowNow, tell your workflow to use this specific key instead of the default token. We use the webfactory/ssh-agent action to handle the SSH handshake seamlessly.File: .github/workflows/deploy.ymlYAMLname: Secure Private Push

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          # This ensures the checkout uses the SSH key, not the default token
          ssh-key: ${{ secrets.SSH_DEPLOY_KEY }}

      - name: Configure Git
        run: |
          git config --global user.name "CI Bot"
          git config --global user.email "ci-bot@example.com"

      - name: Make a Change (Example)
        run: |
          date > last_deploy.txt
          
      - name: Push to Private Repo
        run: |
          git add last_deploy.txt
          git commit -m "Update deployment timestamp [skip ci]"
          git push origin main
Note: Adding [skip ci] to your commit message prevents the bot from triggering an infinite loop of workflows.Environment Variables ChecklistWhen using this setup, these are the variables being utilized:VariableSourcePurposeSSH_AUTH_SOCKCreated by SSH AgentEnables SSH commands to find your key.GITHUB_ACTORProvided by GitHubIdentifies who triggered the run.SSH_DEPLOY_KEYGitHub SecretsThe raw private key used for authentication.Summary of BenefitsScoped Access: Access is limited to one repository.No Personal Link: The key doesn't break if a specific team member leaves the company.Bypasses 2FA: Unlike passwords, SSH keys don't require manual multi-factor prompts during automation.Would you like me to show you how to set up a "Matrix Build" so your Ansible roles are tested against multiple Linux distributions (like Ubuntu, Debian, and CentOS) simultaneously?
